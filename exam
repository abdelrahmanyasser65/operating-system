// Synchoronization
gcc fname.c -lpthread
./a.out
___________________________________________________
--Race Condition--
#include<pthread.h>
#include<stdio.h>
#include<unistd.h>
void *fun1();
void *fun2();
int shared=1;
int main(){
pthread_t thread1, thread2;
pthread_create(&thread1,NULL,fun1,NULL);
pthread_create(&thread2,NULL,fun2,NULL);
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
printf("final value of shared is %d\n",shared);
}

void *fun1(){
    int x ;
    x=shared;
    printf("Thread 1 reads the value of shared variable as %d",x);
    x++;
    printf("Local updation by Thread1 %d\n",x);
    sleep(1);
    shared=x;
    printf("valeu of shared variable update by Thread1 is %d\n",shared);
}

void *fun2(){
    int y ;
    y=shared;
    printf("Thread2 reads the value as %d\n",y);
    y--;
    printf("Local upadation by Thread2 : %d\n",y);
    sleep(1);
    shared=y;
    printf("value of shared variable update by Thread2 is : %d\n",shared);
}

___________________________________________________
--Mutex Locks--
#include<pthread.h>
#include<stdio.h>
#include<unistd.h>
void *fun1();
void *fun2();
int shared=1;
pthread_mutex_t l;
int main(){
    pthread_mutex_init(&l,NULL);
    pthread_t thread1, thread2;
    pthread_create(&thread1,NULL,fun1,NULL);
    pthread_create(&thread2,NULL,fun2,NULL);
    pthread_join(thread1,NULL);
    pthread_join(thread2,NULL);
    printf("final value of shared is %d\n",shared);
}
void *fun1(){
int x ;
printf("Thread1 trying to acquire lock\n");
pthread_mutex_lock(&l);
printf("Thread1 acquired lock\n");
x=shared;
printf("thread1 reads the value of shared variable as %d\n",x);
x++;
printf("local updation by Thread1 %d\n",x);
sleep(1);
shared=x;
printf("value of shared variable upldate by thread 1 is %d\n",shared);
pthread_mutex_unlock(&l);
printf("Thread1 released the lock\n");
}

void *fun2(){
    int y ;
    printf("thread2 trying to acquire lock\n");
    pthread_mutex_lock(&l);
    printf("Thread2 acquired lock\n");
    y=shared;
    printf("Thread2 reads the value as %d\n",y);
    y--;
    printf("local updation by Thread2 %d\n",y);
    sleep(1);
    shared=y;
    printf("value of shared variable ypdated by Thread2 is %d\n",shared);
    pthread_mutex_unlock(&l);
    printf("Thread2 released the Lock\n");
}

___________________________________________________
--Semaphores--

#include<pthread.h>
#include<stdio.h>
#include<semaphore.h>
#include<unistd.h>
void *fun1();
void *fun2();
int shared=1;
sem_t s ;
int main(){
sem_init(&s,0,1);
pthread_t thread1,thread2;
pthread_create(&thread1,NULL,fun1,NULL);
pthread_create(&thread2,NULL,fun2,NULL);
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
printf("final value of shared is %d\n",shared);
}

void*fun1(){
int x ;
sem_wait(&s);
x=shared;
printf("Thread1 reads the value as %d\n",x);
x++;
printf("Local updation by Thread1 : %d\n",x);
sleep(1);
shared=x;
printf("value of shared variable updated by Thread1 is : %d\n",shared);
sem_post(&s);
}

void *fun2(){
int y ;
sem_wait(&s);
y=shared;
printf("Thread2 reads the value as %d\n",y);
y--;
printf("local updation by thread2 : %d\n",y);
sleep(1);
shared=y;
printf("value of shared variable updated by Thread2 is %d\n", shared);
sem_post(&s);
}

___________________________________________________
--Dining Philosopher Problem--

#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>
sem_t chopstick[5];
void *philos(void*);
void eat(int);
int main(){
int i,n[5];
pthread_t T[5];
for(i=0;i<5;i++){
sem_init(&chopstick[i],0,1);
}
for(i=0;i<5;i++){
n[i]=i;
pthread_create(&T[i],NULL,philos,(void*)&n[i]);
}

for(i=0;i<5;i++){
pthread_join(T[i],NULL);
}
}
void *philos(void*n){
int ph=*(int*)n;
printf("philospher %d wants to eat\n",ph);
printf("Philospher %d tries to pick left chopstick\n",ph);
sem_wait(&chopstick[ph]);
printf("philospher %d picks the left chopstick\n",ph);
printf("Philospher %d  tries to pick the right chipstick\n",ph);
sem_wait(&chopstick[(ph+1)%5]);
printf("philosopher %d picks the right chopstick\n",ph);
eat(ph);
sleep(2);
printf("Philosopher %d has finished eating \n",ph);
sem_post(&chopstick[(ph+1)%5]);
printf("philosopher %d leaves the right chipstick\n",ph);
sem_post(&chopstick[ph]);
printf("philosopher %d leaves the left chopstick\n",ph);
}
void eat(int ph)
{
printf("philosopher %d begins to eat \n",ph);
}


___________________________________________________
___________________________________________________
___________________________________________________
// DeadLock
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>
void *fun1();
void *fun2();
pthread_mutex_t first_mutex;
pthread_mutex_t second_mutex;

int main(){
pthread_mutex_init(&first_mutex,NULL);
pthread_mutex_init(&second_mutex,NULL);
pthread_t one,two;
pthread_create(&one,NULL,fun1(),NULL);
pthread_create(&two,NULL,fun2(),NULL);
pthread_join(one,NULL);
pthread_join(two,NULL);
printf("Thread Joined\n");
}

void*fun1(){

pthread_mutex_lock(&first_mutex);
printf("T1 acquired first mutex\n");
sleep(1);
pthread_mutex_lock(&second_mutex);
printf("T1 acquired second mutex\n");
pthread_mutex_unlock(&second_mutex);
printf("T1 released second mutex\n");
pthread_mutex_unlock(&first_mutex);
printf("T1 released first mutes\n");
}

void *fun2(){
pthread_mutex_lock(&second_mutex);
printf("T2 acquired second mutex\n");
sleep(1);
pthread_mutex_lock(&first_mutex);
printf("T2 acquired first mutex\n");
pthread_mutex_unlock(&first_mutex);
printf("T2 released first mutex\n");
pthread_mutex_unlock(&second_mutex);
printf("T2 released second mutex\n");
}
___________________________________________________
___________________________________________________
___________________________________________________
//Thread

Thread prints 0-4 + main 20_24

#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
void*thread_fun(void*args);
int i,n,j;
int main(){
pthread_t thread;
pthread_create(&thread,NULL,thread_fun,NULL);
pthread_join(thread,NULL);
printf("inside main program\n");
for(j=20;j<=24;j++){
printf("%d\n",j);
sleep(1);
}
}
void*thread_fun(void*args){
printf("inside thread\n");
for(i=0;i<5;i++){
printf("%d\n",i);
sleep(1);
}
}
___________________________________________________
--a thread returns a value to the main process--
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>
#include<string.h>
void*thread_fun(void*arg);
int i,n,j;
int main(){
char *m="5";
pthread_t thread;
void*result;
pthread_create(&thread,NULL,thread_fun,m);
pthread_join(thread,result);
printf("Thread Joined\n");
for(j=20;j<25;j++){
printf("%d\n",j);
sleep(1);
}
printf("thread retunred %s\n",(char*)result);
}

void *thread_fun(void*arg){
int sum=0;
n=atoi(arg);
for(i=0;i<n;i++){
printf("%d\n",i);
sleep(1);
}
pthread_exit("Done");
}
___________________________________________________
-- pass multiple values to a thread using structure--
#include<stdio.h>
#include<pthread.h>
struct arg_struct{
int arg1;
int arg2;
};
void *arguments(void*arguments){
struct arg_struct*args=arguments;
printf("%d\n",args->arg1);
printf("%d\n",args->arg2);
pthread_exit(NULL);
}
int main()
{
pthread_t t;
struct arg_struct args;
args.arg1=5;
args.arg2=7;
pthread_create(&t,NULL,arguments,&args);
pthread_join(t,NULL);
}
___________________________________________________
--create a thread to add two numbers--
#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
void *thread_fun(void*args);
int num[2]={3,5};
int main(){
pthread_t t;
void *result;
pthread_create(&t,NULL,thread_fun,(void*)num);
pthread_join(t,&result);
printf("inside main program\n");
printf("Thread returned: %s\n",(char*)result);
}
void *thread_fun(void*args){
printf("inside thread\n");
int*x=args;
int sum=x[0]+x[1];
printf("sum is %d\n",sum);
pthread_exit("sum calculated");
}